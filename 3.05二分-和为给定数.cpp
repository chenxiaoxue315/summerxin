/* 描述
给出若干个整数，询问其中是否有一对数的和等于给定的数。
输入
共三行：
第一行是整数n(0 < n <= 100,000)，表示有n个整数。
第二行是n个整数。整数的范围是在0到10^8之间。
第三行是一个整数m（0 <= m <= 2^30)，表示需要得到的和。
输出
若存在和为m的数对，输出两个整数，小的在前，大的在后，中间用单个空格隔开。若有多个数对满足条件，选择数对中较小的数更小的。若找不到符合要求的数对，输出一行No。
样例输入
4
2 5 1 4
6
样例输出
1 5*/
/*二分法的话我们这就可以从第i个数找起，因为这是排序好的了，所以i之前的肯定已经找过了，看i之后的是否有符合条件的，于是我们找到左右界限，左界就是i+1，右界肯定是数组最后一个数，所以是n-1，然后找到找中间的，如果中间的和第i个数相加大了，说明中间的数取大了，得往左找，反之往右。思路差不多就是这样*/
#include<bits/stdc++.h>
using namespace std;
int a[100000];
int main()
{	
    int n,m,l,r,mid;
    cin>>n;//n代表数组的个数 
    for(int i=0;i<n;i++)
    cin>>a[i];
    cin>>m;//m是和  
    sort(a,a+n);//对输入的所有数进行排序 方便找到最小的那个符合条件的
    for(int i=0;i<n;i++)//从第一个元素开始找
    {
    	l=i+1;//左界
	    r=n-1;//右界
    	while(l<=r)
    	{
    		mid = (l+r)/2;
    		if(a[i]+a[mid]==m)//如果此时中间的数和a【i】加起来正好是m直接输出并且return 0
    		{
    			cout<<a[i]<<" "<<a[mid];
    			return 0;
			}
			else if(a[mid]+a[i]>m) r=mid-1;//如果偏大就往左找
			else l=mid+1;//否则往右边找
		}
	}
	cout<<"No";//到这时说明上面没找到符合条件的 输出no就可以了
}
