/*给定一个只包含 ‘(’ 和 ‘)’ 的字符串，找出最长的包含有效括号的子串的长度。
示例 1:
输入: “(()”
输出: 2
解释: 最长有效括号子串为 “()”
示例 2:
输入: “)()())”
输出: 4
解释: 最长有效括号子串为 “()()”*/ 
/*用dp数组记录以当前字符为尾的最长有效括号，显然只有在当前字符是右括号)时才有可能有有效子串，所以分两种情况：
1.当前字符s[i]是右括号)，且前一个符号是左括号(。这种情况字符串是这样的“…()”，所以dp[i]=dp[i?2]+2，即前面最长连续有效括号加现在的两个。
2.当前字符s[i]是右括号)，且前一个符号也是右括号)。这种情况字符串是这样的“…))”，这时要判断以前一个右括号为尾的最长有效括号之前的一个字符是否是左括号(，如果是左括号，即“…((…))”，则dp[i]应该等于它和它对应左括号中间的有效括号数dp[i?1]加现在的两个，再加对应左括号之前的最长有效括号数dp[i?dp[i?1]?2]，即dp[i]=dp[i?1]+dp[i?dp[i?1]?2]+2；如果是右括号，即“…)(…))”，则dp[i]是0.*/
class Solution {
public:
    int longestValidParentheses(string s) {
        if(s.length()==0) return 0;
        int res=0;
        vector<int> dp;
        for(int i=0;i<s.length();i++){
            dp.push_back(0);
        }
        for(int i=1;i<s.length();i++){
            if(s[i]==')'){
                if(s[i-1]=='(') dp[i]=(i-2<0?0:dp[i-2])+2;
                else{
                    if((i-dp[i-1]-1>=0)&&s[i-dp[i-1]-1]=='('){
                        dp[i]=(i-dp[i-1]-2<0?0:dp[i-dp[i-1]-2])+2+dp[i-1];
                    }
                }
            }
            res=max(res,dp[i]);
        }
        return res;
    }
};

