/*描述
已知矩阵的大小定义为矩阵中所有元素的和。给定一个矩阵，你的任务是找到最大的非空(大小至少是1 * 1)子矩阵。
比如，如下4 * 4的矩阵
0 -2 -7 0
9 2 -6 2
-4 1 -4 1
-1 8 0 -2
的最大子矩阵是
9 2
-4 1
-1 8
这个子矩阵的大小是15。
输入
输入是一个N * N的矩阵。输入的第一行给出N (0 < N <= 100)。再后面的若干行中，依次（首先从左到右给出第一行的N个整数，再从左到右给出第二行的N个整数……）给出矩阵中的N2个整数，整数之间由空白字符分隔（空格或者空行）。已知矩阵中整数的范围都在[-127, 127]。
输出
输出最大子矩阵的大小。
样例输入
4
0 -2 -7 0 9 2 -6 2
-4 1 -4  1 -1
8  0 -2
样例输出
15*/
#include<iostream>
#include<cstdio> 
using namespace std;
//首先是要想到把同一列看做一个数，然后对一行数据求最大连续和 
int n,a[110][110],b[110];
int dp[110],res=0;
void f(int x,int y)
{
	
    for(int i=1;i<=n;i++)
	{
        b[i]=0; dp[i]=0;
        for(int e=x;e<=y;e++)
		{
            //把从第x行到第y行的第i列是数看做一个数
            b[i]+=a[e][i]; 
        } 
        dp[i]=b[i];//初始化 
        if(dp[i-1]>0)
		{
            dp[i]=max(dp[i],dp[i-1]+b[i]);
        }
        res=max(res,dp[i]);
    }
}
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
	{
        for(int j=1;j<=n;j++)
		{
            cin>>a[i][j];
        }
    }
    for(int i=1;i<=n;i++)
	{
        for(int j=i;j<=n;j++)
		{
            //把同一列的看做是一个数 
            f(i,j);
        }
    }
    cout<<res<<endl;
}
